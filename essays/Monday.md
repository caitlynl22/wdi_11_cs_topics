Queues and stacks are at once very similar and completely opposite. Queues and stacks are both data structures, but a queue is first-in-first-out and a stack is last-in-first-out. Queues and stacks are intuitively named in that each term describes very well the function of the structure: queues are like lines in that the first person in the line is the first to leave the line. Stacks are like, well, stacks (of pancakes, plates, pizza, whatever helps you): the last on the stack is the first removed from said stack. To push onto a stack or enqueue an element, make sure there's room in the array, then push your element in the last open slot. To remove - or dequeue - from a queue, remove the item at the head of the queue, then reposition the head to the next element. To remove - or pop - an item from a stack, remove the element at the index of the size of the array.

Arrays are data structures of fixed length in memory (though some programming languages, like Ruby, do have dynamic arrays). An element in an array can be accessed by its index, which, in most languages, starts at zero. Though arrays are good for random access (via indexes), it can be difficult and time-consuming to locate specific items, as you may have to traverse an entire array to locate a single element. A hash table, which is a common data structure used to implement an associative array, is often a better solution when lookup time is a factor. A hash table is an array coupled with a hashing function. A hash function takes a piece of data (referred to as a key) as input and returns an integer that maps to an index in the table. Linked lists are also often used to implement hash tables as a method of dealing with collisions (when more than one key maps to a specific value); the resulting table is an array of pointers to linked lists, which map to their corresponding keys. Choosing a good hash function will make life much easier by preventing collisions in the first place. What is a good hash function? To start with, one that makes use of as much of the key's data as possible in order to maximize the number of potential hash values. Another good way of thinking of this is to be as specific as possible. Along those lines, even if keys are similar, they should map to very different hash values, which minimizes the odds of a collision. Hash values should also be spread as evenly as possible across the table. Finally, a hash function should only use fast operations such as insertion, deletion, and lookup.

Sets are very similar to arrays, though all of a set's values must be unique (if you try to merge two sets in Ruby, for example, the duplicate elements will be removed) and its elements are not indexed. Sets can be helpful when trying to figure out where two sets of data intersect or diverge.
